# Go

## rune 型について
- https://note.com/keyem/n/ndc5593719915
- https://qiita.com/seihmd/items/4a878e7fa340d7963fee
## [配列とスライスの違い](https://qiita.com/tchnkmr/items/10071a53a8bce87b62a3)
- 配列は固定長、スライスは可変長
- 配列はappend()で拡張できない、スライスはできる
- 配列は変数への代入でコピーが作れる、スライスはcopy()を使用しないと作れない
- スライスの変数への代入後の取り扱いには注意する必要あり
## ポインタの用途

- 関数への引数としてポインタを使用する場合
  - 大きなデータ構造やオブジェクトを関数に渡す際、値のコピーを避けるためにポインタを使用する。
  - パフォーマンス向上とメモリ使用量の削減が期待できる。
- 関数内での値の変更が必要な場合
  - 関数内で引数の値を変更する必要がある場合、ポインタを使用することで呼び出し元に影響を及ぼせる。
- 動的なデータ構造の操作が必要な場合
  - メモリを動的に確保してデータ構造を操作する際、ポインタを使用することでアクセスと変更を効率的に行える。
  - 例: Linked List や Tree のノードの管理。
- インターフェースの実装においてポインタ型が必要な場合
  - インターフェースのメソッドを実装する際、ポインタレシーバとして定義された型に対してはポインタを使用する必要がある。
  - インターフェースによる多態性を実現できる。
- ゼロ値を避けるためにポインタを使用する場合:
  - ポインタを使用することで変数を nil で初期化し、ゼロ値を避けることができる。
  - 変数が初期化されているかどうかを明示的にチェックできる。

## ポインタの注意点
- ヌル ポインタ エクセプションに注意
  - ポインタが nil を指す可能性がある場合、ポインタを解除する前にチェックを行うこと。
  - ヌル ポインタを解除するとランタイム エラーが発生する。
- ポインタが指すオブジェクトのライフサイクルを適切に管理すること:
  - ポインタが参照するオブジェクトの寿命に注意を払い、必要なくなったら適切に解放すること。
  - 不要な参照が残るとメモリリークの原因となる可能性がある。






